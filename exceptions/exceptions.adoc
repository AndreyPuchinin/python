= Исключения

Если исключение не обрабатывать, пррограмма завершится с ошибкой! Это не всегда удобно, например, когда программа работает сразу с несколькими потоками, процессами или интернет-соединениями. Поэтому и существуют обработчики исключений, чтобы "исправить" и уточнить работу программы при данном исключении.
 
Также исключения можно вызывать (*_raise <Error class type>(<my_message>)_*). Это нужно, например, для того, чтобы функция, которая "не знает", что возвращать из-за ошибки параметров, не возвращала "абы какое" значение, а наоборот прямо сообщила, что не может быть корректно завершенной. Хорошим тоном является raise, как можно раньше, как только возможно.

[source,python]
----
class ArgumentEqualZeroError(Exception): #Всегда наследоваться от Exception!
    """Желательно написать тут комментарий!"""
    pass

class ArgumentIsNotIntError(Exception):
    """Желательно написать тут комментарий!"""
    pass

#Классы создаются для того, чтобы при выводе печаталось их имя.
#Создаваемые классы исключений обычно стоит выносить в отдельный модуль.

def divide(a,b):
    if not isinstance(a,int) or not isinstance(b,int):
        raise ArgumentIsNotIntError('Error! Argument must be num!')
    if b == 0:
        raise ArgumentEqualZeroError('Error! Division by 0!')
    
#print(divide(4,0)) #вызовет исключение ArgumentEqualZeroError: Error! Division by 0!
try:
    print(divide(4,'0')) #выведет Error!
except (ArgumentIsNotIntError,ArgumentEqualZeroError) as exc:
    print(exc)
    raise #Вызывает именно сработавшее исключение из списка
finally: #выполняется ВСЕГДА!
    print('Finished') #Finally - не "безопасная  гавань", она тоже не защищена от ошибок и некорректных вызовов!
#Переменные в блоках выше НЕ ВИДНЫ в finally!
----

В Питоне есть два вида исключений:

* стандартной библиотеки Python
* пользовательские

Дерево наследования исключений:

BaseException
    +-- SystemExit
    +-- KeyboardInterrupt
    +-- GeneratorExit
    +-- Exception
        +-- StopIteration
        +-- AssertionError
        +-- AttributeError
        +-- LookupError
            +-- IndexError
            +-- KeyError
        +-- OSError
        +-- SystemError
        +-- TypeError
        +-- ValueError
        
[source,python]
----
issubclass(KeyError,LookupError) #True
----

Больше исключений в библиотеке reuest
        
В блоке try-except не всегда имеет смысл опускать исключение и реагировать на любое. Например:

[source,python]
----
try:
    #<работа программы>
    int('str')
except:
    #<ошибка работы программы>
----

На самом деле в данном случае ошибка не в логике программы где-то выше - а имено в преобразовании строки к int'у.

Кроме того, исключение может выпадать по разным причинам, и не стоит их смешивать:

[source,python]
----
try:
    #<работа программы>
    int('str')
except <1> as err:
    #<ошибка работы программы1>
    print(err.args[<n>])
    raise <ExceptionClass>('...',<выражения с применением доступных конструкций>)
except <2>:
    #<ошибка работы программы2>
else:
    #не было ошибок
finaly:
    #в любом случае

assert False <some text> #быстрая временная проверка без try-except. Чтобы запустить программу с игнорированием всех assert'ов, надо запустить скрипт через консоль питона с флагом -O

#Exception!: AssertionError: <some text>
----

В исключении можно использовать *break*.
Также сами типы исключений можно объединять в (,). Если все объединенные типы исключений можно заменить на их предка, стоит задуматься о том, чтобы написать одного предка вместо нескольких исключений-наследников.

Try-except могут быть вложенными друг в друга, например, внутри стека вызовов функций.

Обработка исключений не бесплатна!(по времени). Она может занимать на несколько порядков больше времени, чем без неё!

== Создание исключений

